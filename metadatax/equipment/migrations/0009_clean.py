# Generated by Django 3.2.25 on 2025-12-16 14:59
from django.contrib.postgres.aggregates import ArrayAgg
from django.db import migrations
from django.db.models import Q

from metadatax.equipment.models import AcousticDetectorSpecification


def _clean_spec(apps, model, distinct, filter):
    ContentType = apps.get_model("contenttypes", "ContentType")
    EquipmentModelSpecification = apps.get_model("equipment", "EquipmentModelSpecification")

    type = ContentType.objects.get_for_model(model)
    for spec in model.objects.distinct(*distinct):
        duplicates = model.objects.filter(filter(spec)).filter(~Q(id=spec.id))

        for rel in EquipmentModelSpecification.objects.filter(specification_type=type,
                                                              specification_id__in=duplicates.values_list("id",
                                                                                                          flat=True)):
            rel.specification_id = spec.id
            rel.save()

        duplicates.delete()

def clean_recorder(apps, _):
    RecorderSpecification = apps.get_model("equipment", "RecorderSpecification")
    _clean_spec(
        apps,
        model=RecorderSpecification,
        distinct=[
            "channels_count",
            "storage_slots_count",
            "storage_maximum_capacity",
            "storage_type",
        ],
        filter=lambda spec: Q(
            channels_count=spec.channels_count,
            storage_slots_count=spec.storage_slots_count,
            storage_maximum_capacity=spec.storage_maximum_capacity,
            storage_type=spec.storage_type,
        )
    )

def clean_hydrophone(apps, _):
    HydrophoneSpecification = apps.get_model("equipment", "HydrophoneSpecification")
    _clean_spec(
        apps,
        model=HydrophoneSpecification,
        distinct=[
            "directivity",
            "operating_min_temperature",
            "operating_max_temperature",
            "min_bandwidth",
            "max_bandwidth",
            "min_dynamic_range",
            "max_dynamic_range",
            "min_operating_depth",
            "max_operating_depth",
            "noise_floor",
        ],
        filter=lambda spec: Q(
            directivity=spec.directivity,
            operating_min_temperature=spec.operating_min_temperature,
            operating_max_temperature=spec.operating_max_temperature,
            min_bandwidth=spec.min_bandwidth,
            max_bandwidth=spec.max_bandwidth,
            min_dynamic_range=spec.min_dynamic_range,
            max_dynamic_range=spec.max_dynamic_range,
            min_operating_depth=spec.min_operating_depth,
            max_operating_depth=spec.max_operating_depth,
            noise_floor=spec.noise_floor,
        )
    )

def clean_storage(apps, _):
    StorageSpecification = apps.get_model("equipment", "StorageSpecification")
    _clean_spec(
        apps,
        model=StorageSpecification,
        distinct=[
            "capacity",
            "type",
        ],
        filter=lambda spec: Q(
            capacity=spec.capacity,
            type=spec.type,
        )
    )

def clean_detector(apps, _):
    # AcousticDetectorSpecification = apps.get_model("equipment", "AcousticDetectorSpecification")
    ContentType = apps.get_model("contenttypes", "ContentType")
    EquipmentModelSpecification = apps.get_model("equipment", "EquipmentModelSpecification")

    type = ContentType.objects.get_for_model(AcousticDetectorSpecification)

    duplicates_id = []
    for spec in AcousticDetectorSpecification.objects.all():
        if spec.id in duplicates_id:
            continue

        duplicates = AcousticDetectorSpecification.objects.filter(
            ~Q(id=spec.id)
        ).filter(
            min_frequency=spec.min_frequency,
            max_frequency=spec.max_frequency,
            algorithm_name=spec.algorithm_name,
        )
        for d in duplicates:
            spec_labels = spec.detected_labels.order_by('id').values_list("id", flat=True)
            duplicate_labels = d.detected_labels.order_by('id').values_list("id", flat=True)
            if spec_labels == duplicate_labels:
                duplicates_id.append(d.id)

            for rel in EquipmentModelSpecification.objects.filter(specification_type=type,
                                                                  specification_id=d.id):
                rel.specification_id = spec.id
                rel.save()

    AcousticDetectorSpecification.objects.filter(id__in=duplicates_id).delete()


def clean_relations(apps, _):
    EquipmentModelSpecification = apps.get_model("equipment", "EquipmentModelSpecification")

    for rel in EquipmentModelSpecification.objects.distinct('model', 'specification_type', 'specification_id'):
        EquipmentModelSpecification.objects.filter(
            model=rel.model,
            specification_type=rel.specification_type,
            specification_id=rel.specification_id,
        ).filter(~Q(id=rel.id)).delete()



class Migration(migrations.Migration):
    dependencies = [
        ('equipment', '0008_equipment_owner'),
    ]

    operations = [
        migrations.RunPython(clean_recorder, migrations.RunPython.noop),
        migrations.RunPython(clean_hydrophone, migrations.RunPython.noop),
        migrations.RunPython(clean_storage, migrations.RunPython.noop),
        migrations.RunPython(clean_detector, migrations.RunPython.noop),

        migrations.RunPython(clean_relations, migrations.RunPython.noop),
    ]
